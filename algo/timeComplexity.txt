Function huffmanEncode(C)   

							    Cost               Times

1   n = C.size    		           		     C1			1
2   Q = priority_queue()            		      	     C2			1

3   for i = 1 to n		          		     C3			N+1
4     n = node(C[i]) 	                                     C4                 N
5     Q.push(n)				        	     C5			summation(tj) from j=1 to n       
6   end for

7   while Q.size() is not equal to 1                         C6			N+1
8      Z = new node()			      	 	     C7			N
9      Z.left = x = Q.pop			       	     C8			N
10     Z.right = y = Q.pop			             C9			N
11     Z.frequency = x.frequency + y.frequency               C10		N
12     Q.push(Z)        				     C11		summation(Tq.size()) from Q.size() to 1								Q.size()
13  end while
14 Return Q   					             C12		1

Analysis:

The Ruuning time for this algorithm is sum of all the  individual steps invloved in this algorithm which compute and tells 
time T(n).
T(n) = C1 + C2 + C3(N+1) + C4(N)+ C5[Summation(Tj) from j=1 to n] + C6(N+1) + C7(N) + C8(N) + C9(N) + C10(N) + 
	C11[Summation(tj) from Q.size() to 1] + C12
In the above expression we can see that on line 3 & 7 the loop executes for N+1 times because each loop executers N times 
plus 1 more time to check for the false condition or terminating condition. In the rest of the code the lines that are
in body of loop gets executed for N times and outside the body executes for the Constant time except all the lines in
which push function of priority queue is called. In these lines further loop executes in push function to locate the 
position of new node and set it their, In this step time complexity becames same as using a nested loop so we have 
to calculate a new time Tj and Tq.size() for these lines.
Best Case:
	  For optimal condtion we would consider that at line 5 & 12 the node will be inserted at its first iteration of loop
	  or at the start of queue using constant time making Tj & Tq.size() = 1 and the whole line will be executed 
	  respectively to loop.
	  T(n) = (C3 + C4 + C5 + C6 + C7 + C8 + C9 + C10 + C11)N + (C1 + C2 + C3 + C6 + C12)
	  Making this a linear function an+b and running time of O(n).
Worst Case:
	  In worst case the summation would run through whole array or set Tj = n(n+1)/2 while in Tq.size() assuming that
	  the size starts from n and completes the whole set or array then it would also become same as Tj which is
	  n(n+1)/2
	  So T(n) = C1 + C2 + C3(N+1) + C4(N) + C5(n(n+1)/2) + C6(N+1) + C7(N) + C8(N) +C9(N) + C10(N) + C11(n(n+1)/2) +
		    C12
		  = ((C5 +C11)N^2)/2 + (C3 + C4 + C5 + C6 + C7 + C8 + C9 + C10 + C11)N + 
		    (C1 + C2 + C3 + 1/2(C5 +C11) + C6 + C12)
          Making this a quadratic function  AN^2 + BN + C and O(N^2) which is similar to insertion sort etc.